import numpy as np
from typing import Dict, Any, List, Tuple, Union

def piv_manipulate_data(action: str, *args: Any) -> Dict[str, Any]:
    """
    Manipulation of data structures generated by PIVsuite.

    Args:
        action (str): Defines how the data will be manipulated.
        *args (Any): Variable length argument list for different actions.

    Returns:
        Dict[str, Any]: Manipulated PIV data structure.
    """
    piv_data_out = {}

    if action.lower() == 'initsequencedata':
        piv_data_in, nt = args
        nx, ny = piv_data_in['X'].shape
        piv_data_out = {
            'X': piv_data_in['X'].astype(np.float32),
            'Y': piv_data_in['Y'].astype(np.float32),
            'U': np.full((ny, nx, nt), np.nan, dtype=np.float32),
            'V': np.full((ny, nx, nt), np.nan, dtype=np.float32),
            'Status': np.full((ny, nx, nt), 255, dtype=np.uint16),
            'N': piv_data_in['N'],
            'iaSizeX': piv_data_in['iaSizeX'],
            'iaSizeY': piv_data_in['iaSizeY'],
            'iaStepX': piv_data_in['iaStepX'],
            'iaStepY': piv_data_in['iaStepY'],
            'imSizeX': piv_data_in['imSizeX'],
            'imSizeY': piv_data_in['imSizeY'],
            'ccPeak': np.full((ny, nx, nt), np.nan, dtype=np.float32),
            'ccPeakSecondary': np.full((ny, nx, nt), np.nan, dtype=np.float32),
            'ccFailedN': np.zeros(nt, dtype=int),
            'ccSubpxFailedN': np.zeros(nt, dtype=int),
            'maskedN': np.zeros(nt, dtype=int),
            'replacedN': np.zeros(nt, dtype=int),
            'spuriousN': np.zeros(nt, dtype=int)
        }
        piv_data_out['U'][:, :, 0] = piv_data_in['U'].astype(np.float32)
        piv_data_out['V'][:, :, 0] = piv_data_in['V'].astype(np.float32)
        piv_data_out['Status'][:, :, 0] = piv_data_in['Status'].astype(np.uint16)
        piv_data_out['ccPeak'][:, :, 0] = piv_data_in['ccPeak'].astype(np.float32)
        piv_data_out['ccPeakSecondary'][:, :, 0] = piv_data_in['ccPeakSecondary'].astype(np.float32)
        piv_data_out['ccFailedN'][0] = piv_data_in['ccFailedN']
        piv_data_out['ccSubpxFailedN'][0] = piv_data_in['ccSubpxFailedN']
        piv_data_out['maskedN'][0] = piv_data_in['maskedN']
        piv_data_out['replacedN'][0] = piv_data_in['replacedN']
        piv_data_out['spuriousN'][0] = piv_data_in['spuriousN']

        optional_fields = ['ccStd1', 'ccStd2', 'ccMean1', 'ccMean2', 'multiplicator']
        for field in optional_fields:
            if field in piv_data_in:
                piv_data_out[field] = np.full((ny, nx, nt), np.nan, dtype=np.float32)
                piv_data_out[field][:, :, 0] = piv_data_in[field].astype(np.float32)

    elif action.lower() == 'writetimeslice':
        piv_data_seq, piv_data_in, kt = args
        if not (np.array_equal(piv_data_seq['X'], piv_data_in['X']) and np.array_equal(piv_data_seq['Y'], piv_data_in['Y'])):
            raise ValueError("Measurement grid is not compatible.")

        piv_data_out = piv_data_seq.copy()
        piv_data_out['U'][:, :, kt] = piv_data_in['U'].astype(np.float32)
        piv_data_out['V'][:, :, kt] = piv_data_in['V'].astype(np.float32)
        piv_data_out['Status'][:, :, kt] = piv_data_in['Status'].astype(np.uint16)
        piv_data_out['ccPeak'][:, :, kt] = piv_data_in['ccPeak'].astype(np.float32)
        piv_data_out['ccPeakSecondary'][:, :, kt] = piv_data_in['ccPeakSecondary'].astype(np.float32)
        piv_data_out['ccFailedN'][kt] = piv_data_in['ccFailedN']
        piv_data_out['ccSubpxFailedN'][kt] = piv_data_in['ccSubpxFailedN']
        piv_data_out['maskedN'][kt] = piv_data_in['maskedN']
        piv_data_out['replacedN'][kt] = piv_data_in['replacedN']
        piv_data_out['spuriousN'][kt] = piv_data_in['spuriousN']

        optional_fields = ['ccStd1', 'ccStd2', 'ccMean1', 'ccMean2', 'multiplicator']
        for field in optional_fields:
            if field in piv_data_in:
                piv_data_out[field][:, :, kt] = piv_data_in[field].astype(np.float32)

    elif action.lower() == 'readtimeslice':
        piv_data_seq, kt = args
        piv_data_out = {
            'U': piv_data_seq['U'][:, :, kt].astype(np.float64),
            'V': piv_data_seq['V'][:, :, kt].astype(np.float64),
            'Status': piv_data_seq['Status'][:, :, kt].astype(np.uint16),
            'ccPeak': piv_data_seq['ccPeak'][:, :, kt].astype(np.float64),
            'ccPeakSecondary': piv_data_seq['ccPeakSecondary'][:, :, kt].astype(np.float64)
        }
        optional_fields = ['vorticity', 'epsLEPIV', 'ccStd1', 'ccStd2', 'ccMean1', 'ccMean2']
        for field in optional_fields:
            if field in piv_data_seq:
                piv_data_out[field] = piv_data_seq[field][:, :, kt].astype(np.float32)

    elif action.lower() == 'multiplyvelocity':
        piv_data_in, mult = args
        piv_data_out = piv_data_in.copy()
        piv_data_out['U'] = piv_data_out['U'] * mult
        piv_data_out['V'] = piv_data_out['V'] * mult
        if 'spuriousU' in piv_data_in:
            piv_data_out['spuriousU'] = piv_data_out['spuriousU'] * mult
        if 'spuriousV' in piv_data_in:
            piv_data_out['spuriousV'] = piv_data_out['spuriousV'] * mult

    elif action.lower() == 'combinedata':
        piv_data1, piv_data2 = args[:2]
        UmagMax = args[2] if len(args) > 2 else (piv_data1['iaSizeX'] + piv_data1['iaSizeY'] + piv_data2['iaSizeX'] + piv_data2['iaSizeY']) / 4
        min_detectability = args[3] if len(args) > 3 else 0.08
        mult1 = args[4] if len(args) > 4 else (piv_data1['imNo2'][0] - piv_data1['imNo1'][0])
        mult2 = args[5] if len(args) > 5 else (piv_data2['imNo2'][0] - piv_data2['imNo1'][0])

        if not (np.array_equal(piv_data1['X'], piv_data2['X']) and np.array_equal(piv_data1['Y'], piv_data2['Y'])):
            raise ValueError("Measurement grid is not compatible.")

        piv_data_out = piv_data1.copy()
        if 'multiplicator' not in piv_data1:
            piv_data1['multiplicator'] = np.ones_like(piv_data1['U']) * mult1
        if 'multiplicator' not in piv_data2:
            piv_data2['multiplicator'] = np.ones_like(piv_data2['U']) * mult2

        piv_data2['ccPeak'][np.isnan(piv_data2['ccPeak'])] = 0.001
        piv_data_out['ccPeak'][np.isnan(piv_data_out['ccPeak'])] = 0.001
        piv_data2['ccPeakSecondary'][np.isnan(piv_data2['ccPeakSecondary'])] = piv_data2['ccPeak'][np.isnan(piv_data2['ccPeakSecondary'])]
        piv_data_out['ccPeakSecondary'][np.isnan(piv_data_out['ccPeakSecondary'])] = piv_data_out['ccPeak'][np.isnan(piv_data_out['ccPeakSecondary'])]

        Umag2 = np.minimum(np.sqrt(piv_data2['U']**2 + piv_data2['V']**2), UmagMax)
        UmagOut = np.minimum(np.sqrt(piv_data_out['U']**2 + piv_data_out['V']**2), UmagMax)

        score_out = np.maximum((piv_data_out['ccPeak'] - piv_data_out['ccPeakSecondary'] - min_detectability), 0)
        score_out = piv_data_out['multiplicator'] * UmagOut * score_out
        score2 = np.maximum((piv_data2['ccPeak'] - piv_data2['ccPeakSecondary'] - min_detectability), 0)
        score2 = piv_data2['multiplicator'] * Umag2 * score2

        better_score = score_out < score2
        piv_data_out['U'][better_score] = piv_data2['U'][better_score]
        piv_data_out['V'][better_score] = piv_data2['V'][better_score]
        piv_data_out['Status'][better_score] = piv_data2['Status'][better_score]
        piv_data_out['ccPeak'][better_score] = piv_data2['ccPeak'][better_score]
        piv_data_out['ccPeakSecondary'][better_score] = piv_data2['ccPeakSecondary'][better_score]
        piv_data_out['multiplicator'][better_score] = piv_data2['multiplicator'][better_score]

    elif action.lower() in ['limitx', 'limity', 'limitxy']:
        piv_data_in, limits = args
        if action.lower() == 'limitx':
            xmin, xmax = limits
            ymin, ymax = -np.inf, np.inf
        elif action.lower() == 'limity':
            ymin, ymax = limits
            xmin, xmax = -np.inf, np.inf
        elif action.lower() == 'limitxy':
            xmin, xmax, ymin, ymax = limits

        x_keep = (piv_data_in['X'][0, :] >= xmin) & (piv_data_in['X'][0, :] <= xmax)
        y_keep = (piv_data_in['Y'][:, 0] >= ymin) & (piv_data_in['Y'][:, 0] <= ymax)

        piv_data_out = {key: value[np.ix_(y_keep, x_keep)] if isinstance(value, np.ndarray) and value.ndim >= 2 else value
                         for key, value in piv_data_in.items()}

    else:
        raise ValueError(f"Action '{action}' is not recognized.")

    return piv_data_out

def diff_field(F: np.ndarray, X: np.ndarray, dim: int) -> np.ndarray:
    """
    Computes central difference dF/dX, where F is a 2D or 3D field, X is a 2D matrix with coordinates;
    dim defines along which dimension X is varied (use dim = 1 for differentiating across rows,
    and dim=2 for differentiating across columns).

    Args:
        F (np.ndarray): The field to differentiate.
        X (np.ndarray): The coordinates matrix.
        dim (int): The dimension along which to differentiate.

    Returns:
        np.ndarray: The differentiated field.
    """
    F1 = np.full((F.shape[0] + 2, F.shape[1] + 2, F.shape[2]), np.nan)
    F2 = F1.copy()
    X1 = np.full((X.shape[0] + 2, X.shape[1] + 2), np.nan)
    X2 = X1.copy()

    if dim == 1:
        F2[2:-1, 1:-2, :] = F
        F1[1:-3, 1:-2, :] = F
        X2[2:-1, 1:-2] = X
        X1[1:-3, 1:-2] = X
    elif dim == 2:
        F2[1:-2, 2:-1, :] = F
        F1[1:-2, 1:-3, :] = F
        X2[1:-2, 2:-1] = X
        X1[1:-2, 1:-3] = X
    else:
        raise ValueError("Invalid dimension for differentiation.")

    D = F1.copy()
    for k in range(F.shape[2]):
        D[:, :, k] = (F2[:, :, k] - F1[:, :, k]) / (X2 - X1)

    return D[1:-1, 1:-1, :]
